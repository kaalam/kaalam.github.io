<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Jazz: jzzBLOCKS Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Jazz
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">jzzBLOCKS Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="jzzBLOCKS_8h_source.html">jzzBLOCKS.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for jzzBLOCKS:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classjzzBLOCKS.png" usemap="#jzzBLOCKS_map" alt=""/>
  <map id="jzzBLOCKS_map" name="jzzBLOCKS_map">
<area href="classjazzService.html" alt="jazzService" shape="rect" coords="0,0,106,24"/>
<area href="classjzzBLOCKCONV.html" alt="jzzBLOCKCONV" shape="rect" coords="0,112,106,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6d014f1137e8adecf57f89d0d86c3de1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a6d014f1137e8adecf57f89d0d86c3de1">jzzBLOCKS</a> ()</td></tr>
<tr class="memdesc:a6d014f1137e8adecf57f89d0d86c3de1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lowest level of persisted data management: the blocks.  <a href="#a6d014f1137e8adecf57f89d0d86c3de1">More...</a><br /></td></tr>
<tr class="separator:a6d014f1137e8adecf57f89d0d86c3de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6352609c085e9faa979d84f1afa55fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#ad6352609c085e9faa979d84f1afa55fa">~jzzBLOCKS</a> ()</td></tr>
<tr class="separator:ad6352609c085e9faa979d84f1afa55fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff3602a2a29e159dd696922929a1c7f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a7ff3602a2a29e159dd696922929a1c7f">start</a> ()</td></tr>
<tr class="separator:a7ff3602a2a29e159dd696922929a1c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41357cdf599a7a763422ac0c0e2b973"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#ae41357cdf599a7a763422ac0c0e2b973">stop</a> ()</td></tr>
<tr class="separator:ae41357cdf599a7a763422ac0c0e2b973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec728ae2375cde2a460a0ca5d845dd9d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#aec728ae2375cde2a460a0ca5d845dd9d">reload</a> ()</td></tr>
<tr class="separator:aec728ae2375cde2a460a0ca5d845dd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783907d6a43158cec15ab36fb5d21b99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a783907d6a43158cec15ab36fb5d21b99">new_block_C_BOOL_rep</a> (<a class="el" href="jazzCommons_8h.html#ab445aeb9ff3b0956d22aa990f41b240a">pBoolBlock</a> &amp;pb, unsigned char x, int times=1)</td></tr>
<tr class="separator:a783907d6a43158cec15ab36fb5d21b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec6115998cc87a0572d729a54f7a91e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a4ec6115998cc87a0572d729a54f7a91e">new_block_C_INTEGER_rep</a> (<a class="el" href="jazzCommons_8h.html#a127962256c772083f0f393df2909f91f">pIntBlock</a> &amp;pb, int x, int times=1)</td></tr>
<tr class="separator:a4ec6115998cc87a0572d729a54f7a91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4753c9942dafef757c8edc4a244a3c27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a4753c9942dafef757c8edc4a244a3c27">new_block_C_INTEGER_seq</a> (<a class="el" href="jazzCommons_8h.html#a127962256c772083f0f393df2909f91f">pIntBlock</a> &amp;pb, int from, int to, int by=1)</td></tr>
<tr class="separator:a4753c9942dafef757c8edc4a244a3c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df50033255473f597ee93f27abc943d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a3df50033255473f597ee93f27abc943d">new_block_C_REAL_rep</a> (<a class="el" href="jazzCommons_8h.html#adc22cd7c8551bf5965d062da19f3bfc1">pRealBlock</a> &amp;pb, double x, int times=1)</td></tr>
<tr class="separator:a3df50033255473f597ee93f27abc943d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0143be352e704c2dbcaaa87d25b539"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#aad0143be352e704c2dbcaaa87d25b539">new_block_C_REAL_seq</a> (<a class="el" href="jazzCommons_8h.html#adc22cd7c8551bf5965d062da19f3bfc1">pRealBlock</a> &amp;pb, double from, double to, double by=1.0)</td></tr>
<tr class="separator:aad0143be352e704c2dbcaaa87d25b539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd61e4e34e2e6957dec092bcda63898"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a5bd61e4e34e2e6957dec092bcda63898">new_block_C_CHARS_rep</a> (<a class="el" href="jazzCommons_8h.html#aadd3847e953c0a4cb4671bdff4805704">pCharBlock</a> &amp;pb, const char *str, int times=1)</td></tr>
<tr class="separator:a5bd61e4e34e2e6957dec092bcda63898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c608fdbb9b234b768c4fba0f85961d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#aa3c608fdbb9b234b768c4fba0f85961d">new_block_C_RAW_once</a> (<a class="el" href="jazzCommons_8h.html#aa9994b1f3f32f62097cbf195a69143c1">pRawBlock</a> &amp;pb, const void *ps, int size)</td></tr>
<tr class="separator:aa3c608fdbb9b234b768c4fba0f85961d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a2f45f0fcfacfb3a4923b4add5a8d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a99a2f45f0fcfacfb3a4923b4add5a8d1">reinterpret_cast_block</a> (<a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a> pb, int type)</td></tr>
<tr class="separator:a99a2f45f0fcfacfb3a4923b4add5a8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9bd486366fedb09219847e965fdccb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a8f9bd486366fedb09219847e965fdccb">new_block_copy</a> (<a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a> psrc, <a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a> &amp;pdest)</td></tr>
<tr class="separator:a8f9bd486366fedb09219847e965fdccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210476681839337c293c78e83c5eb5b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a210476681839337c293c78e83c5eb5b5">format_C_OFFS_CHARS</a> (<a class="el" href="jazzCommons_8h.html#aadd3847e953c0a4cb4671bdff4805704">pCharBlock</a> pstr, int length)</td></tr>
<tr class="separator:a210476681839337c293c78e83c5eb5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5acfd7a068624197b21bfc1751c553"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#abe5acfd7a068624197b21bfc1751c553">get_string_idx_C_OFFS_CHARS</a> (<a class="el" href="jazzCommons_8h.html#aadd3847e953c0a4cb4671bdff4805704">pCharBlock</a> pstr, const char *string, int len)</td></tr>
<tr class="separator:abe5acfd7a068624197b21bfc1751c553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53acaefd5beecc4e32fabe47ae48981"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#ac53acaefd5beecc4e32fabe47ae48981">realloc_C_OFFS_CHARS</a> (<a class="el" href="jazzCommons_8h.html#aadd3847e953c0a4cb4671bdff4805704">pCharBlock</a> &amp;pstr, int extra_length)</td></tr>
<tr class="separator:ac53acaefd5beecc4e32fabe47ae48981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428ad286f1d7ceafe3826f7b535a0600"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a428ad286f1d7ceafe3826f7b535a0600">open_all_sources</a> ()</td></tr>
<tr class="separator:a428ad286f1d7ceafe3826f7b535a0600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d37e658424ae9e2f88aec48f9ab9346"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a9d37e658424ae9e2f88aec48f9ab9346">num_sources</a> ()</td></tr>
<tr class="separator:a9d37e658424ae9e2f88aec48f9ab9346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91ce223623548083b122b444eb9019d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#af91ce223623548083b122b444eb9019d">source_name</a> (int idx, <a class="el" href="jzzBLOCKS_8h.html#a9c29cd2ce79349cc6968a2aca0a76eb1">sourceName</a> &amp;name)</td></tr>
<tr class="separator:af91ce223623548083b122b444eb9019d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3fa0af4745c757a3b0f59daf2af9f9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a1e3fa0af4745c757a3b0f59daf2af9f9">get_source_idx</a> (const char *name)</td></tr>
<tr class="separator:a1e3fa0af4745c757a3b0f59daf2af9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91e7163989a8a9a6e9453c85cbe1a79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#af91e7163989a8a9a6e9453c85cbe1a79">new_source</a> (const char *name)</td></tr>
<tr class="separator:af91e7163989a8a9a6e9453c85cbe1a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa302c2507dc597b45e63b3e5ad79fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a6aa302c2507dc597b45e63b3e5ad79fe">kill_source</a> (const char *name)</td></tr>
<tr class="separator:a6aa302c2507dc597b45e63b3e5ad79fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186f59ea73fd421b349ddd5e3b7cddbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a186f59ea73fd421b349ddd5e3b7cddbf">close_all_sources</a> ()</td></tr>
<tr class="separator:a186f59ea73fd421b349ddd5e3b7cddbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c09edf5c233d7c5d86d3bda407bae70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a6c09edf5c233d7c5d86d3bda407bae70">block_put</a> (int source, const <a class="el" href="structpersistedKey.html">persistedKey</a> &amp;key, <a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a> block)</td></tr>
<tr class="separator:a6c09edf5c233d7c5d86d3bda407bae70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab954eb93e352f79ea22d147730d958"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a9ab954eb93e352f79ea22d147730d958">block_get</a> (int source, const <a class="el" href="structpersistedKey.html">persistedKey</a> &amp;key, <a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a> &amp;block)</td></tr>
<tr class="separator:a9ab954eb93e352f79ea22d147730d958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0c20e16749cda5e618c4b4e2b20697"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#aac0c20e16749cda5e618c4b4e2b20697">block_kill</a> (int source, const <a class="el" href="structpersistedKey.html">persistedKey</a> &amp;key)</td></tr>
<tr class="separator:aac0c20e16749cda5e618c4b4e2b20697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955485c62a812660310a146bd6702b53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a955485c62a812660310a146bd6702b53">hash_block</a> (<a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a> pblock)</td></tr>
<tr class="separator:a955485c62a812660310a146bd6702b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8f1d9d831c375b0adcde8157b049af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a6a8f1d9d831c375b0adcde8157b049af">compare_headers</a> (<a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a> pb1, <a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a> pb2)</td></tr>
<tr class="separator:a6a8f1d9d831c375b0adcde8157b049af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a93520e5145323cef6aaa7b6153740f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a3a93520e5145323cef6aaa7b6153740f">compare_content</a> (<a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a> pb1, <a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a> pb2)</td></tr>
<tr class="separator:a3a93520e5145323cef6aaa7b6153740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8ba15076849a655a5974852902c8e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#acd8ba15076849a655a5974852902c8e0">char_to_key</a> (const char *pkey, <a class="el" href="structpersistedKey.html">persistedKey</a> &amp;key)</td></tr>
<tr class="separator:acd8ba15076849a655a5974852902c8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8c0ed33ac6ad21feac4d120a232325"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a4f8c0ed33ac6ad21feac4d120a232325">strcmp_keys</a> (const <a class="el" href="structpersistedKey.html">persistedKey</a> key1, const <a class="el" href="structpersistedKey.html">persistedKey</a> key2)</td></tr>
<tr class="separator:a4f8c0ed33ac6ad21feac4d120a232325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc841e46577b9cf110f8bd1987efa76"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a3dc841e46577b9cf110f8bd1987efa76">next_key</a> (int source, <a class="el" href="structpersistedKey.html">persistedKey</a> &amp;key)</td></tr>
<tr class="separator:a3dc841e46577b9cf110f8bd1987efa76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3692c1344a69622159645b90821b2bfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a3692c1344a69622159645b90821b2bfe">set_first_key</a> (<a class="el" href="structpersistedKey.html">persistedKey</a> &amp;key)</td></tr>
<tr class="separator:a3692c1344a69622159645b90821b2bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96957672c632368038a0b090c7bb4d8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#a96957672c632368038a0b090c7bb4d8a">is_last_key</a> (const <a class="el" href="structpersistedKey.html">persistedKey</a> &amp;key)</td></tr>
<tr class="separator:a96957672c632368038a0b090c7bb4d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab95b3472ae05b51381841a278ceb4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classjzzBLOCKS.html#abab95b3472ae05b51381841a278ceb4a">block_unprotect</a> (<a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a> block)</td></tr>
<tr class="separator:abab95b3472ae05b51381841a278ceb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6d014f1137e8adecf57f89d0d86c3de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d014f1137e8adecf57f89d0d86c3de1">&#9670;&nbsp;</a></span>jzzBLOCKS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">jzzBLOCKS::jzzBLOCKS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The lowest level of persisted data management: the blocks. </p>
<p>&lt; This module includes all the LMDB management in the server. The constructor implements the initialization logic that does not depend on configuration since configuration is not available at that time. Starting LMDB also requires configuration. Therefore, most of the initialization is done in Start() and not here. </p>

</div>
</div>
<a id="ad6352609c085e9faa979d84f1afa55fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6352609c085e9faa979d84f1afa55fa">&#9670;&nbsp;</a></span>~jzzBLOCKS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">jzzBLOCKS::~jzzBLOCKS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Any service (logger, configuration, etc.) can be closed before this. Only do non lmdb related finalization here, if necessary. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9ab954eb93e352f79ea22d147730d958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab954eb93e352f79ea22d147730d958">&#9670;&nbsp;</a></span>block_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::block_get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpersistedKey.html">persistedKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read block from persistence. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The index of an open source. (As returned by <a class="el" href="classjzzBLOCKS.html#a1e3fa0af4745c757a3b0f59daf2af9f9">get_source_idx()</a>.) </td></tr>
    <tr><td class="paramname">key</td><td>A key identifying the block in that source. </td></tr>
    <tr><td class="paramname">block</td><td>The address of a pJazzBlock where the result is returned. That pointer MUST be <a class="el" href="classjzzBLOCKS.html#abab95b3472ae05b51381841a278ceb4a">block_unprotect()</a>ed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") EXCEPT for MDB_NOTFOUND where <a class="el" href="classjzzBLOCKS.html#a9ab954eb93e352f79ea22d147730d958">block_get()</a> returns false silently.</dd></dl>
<p>From lmdb: </p><blockquote class="doxtable">
<p>The memory pointed to by the returned values is owned by the lmdb. The caller need not dispose of the memory, and may not modify it in any way. For values returned in a read-only transaction any modification attempts will cause a SIGSEGV. Values returned from the database are valid only until a subsequent update operation, or the end of the transaction. </p>
</blockquote>
<pre class="fragment">The caller does not own this pointer and can only new_block_copy() it in case it needs to be modified and MUST block_unprotect() it when no
</pre><p> longer needed. </p><pre class="fragment">WARNING: A lockless, non-atomic assignment via lock_get_protect_slot()/lock_release_protect_slot() could require a shared use of prot_SP using
</pre><p> a mutex to be thread safe. </p>

</div>
</div>
<a id="aac0c20e16749cda5e618c4b4e2b20697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0c20e16749cda5e618c4b4e2b20697">&#9670;&nbsp;</a></span>block_kill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::block_kill </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpersistedKey.html">persistedKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete block in persistence. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The index of an open source. (As returned by <a class="el" href="classjzzBLOCKS.html#a1e3fa0af4745c757a3b0f59daf2af9f9">get_source_idx()</a>.) </td></tr>
    <tr><td class="paramname">key</td><td>A key identifying the block to be deleted in that source.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not.</dd></dl>
<p>Writing to persistence requires no protected pointer in the source. In case many simultaneous read/write operations concur, the reader can preemptively copy the protected blocks to <a class="el" href="jazzCommons_8h.html#af5b2b15a0f1e5c3d10303c34593b2bfa" title="This macro expands to JAZZALLOCVEC() or JAZZALLOCSTR() and is the ONLY allocation method used!!! ...">JAZZALLOC()</a>ed blocks and return copies of the blocks to make unprotection unnecessary. It has yet to be determined if such a mechanism is necessary and it will not be implemented initially. </p>

</div>
</div>
<a id="a6c09edf5c233d7c5d86d3bda407bae70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c09edf5c233d7c5d86d3bda407bae70">&#9670;&nbsp;</a></span>block_put()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::block_put </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpersistedKey.html">persistedKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a>&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a block to persistence. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The index of an open source. (As returned by <a class="el" href="classjzzBLOCKS.html#a1e3fa0af4745c757a3b0f59daf2af9f9">get_source_idx()</a>.) </td></tr>
    <tr><td class="paramname">key</td><td>A key identifying the block in that source. </td></tr>
    <tr><td class="paramname">block</td><td>The block to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not.</dd></dl>
<p>Writing to persistence requires no protected pointer in the source. In case many simultaneous read/write operations concur, the reader can preemptively copy the protected blocks to <a class="el" href="jazzCommons_8h.html#af5b2b15a0f1e5c3d10303c34593b2bfa" title="This macro expands to JAZZALLOCVEC() or JAZZALLOCSTR() and is the ONLY allocation method used!!! ...">JAZZALLOC()</a>ed blocks and return copies of the blocks to make unprotection unnecessary. It has yet to be determined if such a mechanism is necessary and it will not be implemented initially. </p>

</div>
</div>
<a id="abab95b3472ae05b51381841a278ceb4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab95b3472ae05b51381841a278ceb4a">&#9670;&nbsp;</a></span>block_unprotect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::block_unprotect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a>&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unprotect a pointer (owned by lmdb) returned by <a class="el" href="classjzzBLOCKS.html#a9ab954eb93e352f79ea22d147730d958">block_get()</a> </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The pointer returned by <a class="el" href="classjzzBLOCKS.html#a9ab954eb93e352f79ea22d147730d958">block_get()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not.</dd></dl>
<p>Pointers returned by <a class="el" href="classjzzBLOCKS.html#a9ab954eb93e352f79ea22d147730d958">block_get()</a> must be <a class="el" href="classjzzBLOCKS.html#abab95b3472ae05b51381841a278ceb4a">block_unprotect()</a>ed as soon as a decision on the block can be made. If the caller needs the information contained in the block for a longer time, that block has to be <a class="el" href="classjzzBLOCKS.html#a8f9bd486366fedb09219847e965fdccb">new_block_copy()</a>ed. </p><pre class="fragment">WARNING: A lockless, non-atomic assignment via lock_get_protect_slot()/lock_release_protect_slot() could require a shared use of prot_SP using
</pre><p> a mutex to be thread safe. </p>

</div>
</div>
<a id="acd8ba15076849a655a5974852902c8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd8ba15076849a655a5974852902c8e0">&#9670;&nbsp;</a></span>char_to_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::char_to_key </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpersistedKey.html">persistedKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a char * into a <a class="el" href="structpersistedKey.html">persistedKey</a> or fail if incorrect chars or incorrect length found. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pkey</td><td>The source key as char * </td></tr>
    <tr><td class="paramname">key</td><td>The destination <a class="el" href="structpersistedKey.html">persistedKey</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, does not log. </dd></dl>

</div>
</div>
<a id="a186f59ea73fd421b349ddd5e3b7cddbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186f59ea73fd421b349ddd5e3b7cddbf">&#9670;&nbsp;</a></span>close_all_sources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jzzBLOCKS::close_all_sources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close all sources on lmdb leaving them ready for a subsequent opening.</p>
<p>This makes numsources == 0 by closing used lmdb handles via mdb_dbi_close(). </p>

</div>
</div>
<a id="a3a93520e5145323cef6aaa7b6153740f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a93520e5145323cef6aaa7b6153740f">&#9670;&nbsp;</a></span>compare_content()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::compare_content </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a>&#160;</td>
          <td class="paramname"><em>pb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a>&#160;</td>
          <td class="paramname"><em>pb2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the content of two blocks is identical</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pb1</td><td>A correctly allocated pJazzBlock with a valid header </td></tr>
    <tr><td class="paramname">pb2</td><td>Another correctly allocated pJazzBlock with a valid header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if content (size bytes at data) is identical</dd></dl>
<p>Has no protection mechanism for invalid pointers or corrupted headers. This does NOT check the headers (use <a class="el" href="classjzzBLOCKS.html#a6a8f1d9d831c375b0adcde8157b049af">compare_headers()</a> for that. </p>

</div>
</div>
<a id="a6a8f1d9d831c375b0adcde8157b049af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a8f1d9d831c375b0adcde8157b049af">&#9670;&nbsp;</a></span>compare_headers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::compare_headers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a>&#160;</td>
          <td class="paramname"><em>pb1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a>&#160;</td>
          <td class="paramname"><em>pb2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the headers of two blocks are identical</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pb1</td><td>A correctly allocated pJazzBlock with a valid header </td></tr>
    <tr><td class="paramname">pb2</td><td>Another correctly allocated pJazzBlock with a valid header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if headers are identical</dd></dl>
<p>Has no protection mechanism for invalid pointers. </p>

</div>
</div>
<a id="a210476681839337c293c78e83c5eb5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210476681839337c293c78e83c5eb5b5">&#9670;&nbsp;</a></span>format_C_OFFS_CHARS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::format_C_OFFS_CHARS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#aadd3847e953c0a4cb4671bdff4805704">pCharBlock</a>&#160;</td>
          <td class="paramname"><em>pstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the length of a <a class="el" href="structblock__C__OFFS__CHARS.html">block_C_OFFS_CHARS</a> and initialize its <a class="el" href="structstring__buffer.html">string_buffer</a>[] to contain strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pstr</td><td>A just <a class="el" href="jazzCommons_8h.html#af5b2b15a0f1e5c3d10303c34593b2bfa" title="This macro expands to JAZZALLOCVEC() or JAZZALLOCSTR() and is the ONLY allocation method used!!! ...">JAZZALLOC()</a>ed <a class="el" href="structblock__C__OFFS__CHARS.html">block_C_OFFS_CHARS</a> whose length has not been set yet. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the allocated string vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not.</dd></dl>
<p>The procedure to create a block of strings is: </p><pre class="fragment">pCharBlock pt;

JAZZALLOC(pt, RAM_ALLOC_C_OFFS_CHARS, 16384);// Allocate 16K bytes for a 1000 element vector with many repeated values. Just a guess.
format_C_OFFS_CHARS(pt, 1000);               // Initialize and set the length to 1000, the buffer is ready and the data[] vector full of NA

for(whatever i in 0..999)
    int j = get_string_idx_C_OFFS_CHARS(pt, "My whatever string", strlen(..));
    if (j &gt;= 0)
        pt-&gt;data[i] = j;
    else
        realloc_C_OFFS_CHARS(pt, 4096);     // Add extra 4K each time get_string_idx_C_OFFS_CHARS() fails to allocate a string.</pre> 
</div>
</div>
<a id="a1e3fa0af4745c757a3b0f59daf2af9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3fa0af4745c757a3b0f59daf2af9f9">&#9670;&nbsp;</a></span>get_source_idx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int jzzBLOCKS::get_source_idx </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the index for a source name stored in source[] by searching its name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the source to be found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index or -1 if failed; </dd></dl>

</div>
</div>
<a id="abe5acfd7a068624197b21bfc1751c553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5acfd7a068624197b21bfc1751c553">&#9670;&nbsp;</a></span>get_string_idx_C_OFFS_CHARS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int jzzBLOCKS::get_string_idx_C_OFFS_CHARS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#aadd3847e953c0a4cb4671bdff4805704">pCharBlock</a>&#160;</td>
          <td class="paramname"><em>pstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an existing string in a block, or allocate a new one and return its offset in the <a class="el" href="structstring__buffer.html">string_buffer</a>[].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pstr</td><td>A <a class="el" href="structblock__C__OFFS__CHARS.html">block_C_OFFS_CHARS</a> containing strings. </td></tr>
    <tr><td class="paramname">string</td><td>The string to find or allocate in the <a class="el" href="structstring__buffer.html">string_buffer</a>[]. </td></tr>
    <tr><td class="paramname">len</td><td>The length of "string". This in mandatory to simplify operation with systems where it is known (R and std::string)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The offset to the string if successfully allocated or -1 if allocation failed.</dd></dl>
<p>See <a class="el" href="classjzzBLOCKS.html#a210476681839337c293c78e83c5eb5b5">format_C_OFFS_CHARS()</a> for an explanation on how <a class="el" href="structblock__C__OFFS__CHARS.html">block_C_OFFS_CHARS</a> are filled.</p>
<p>The <a class="el" href="structblock__C__OFFS__CHARS.html">block_C_OFFS_CHARS</a> is designed to be fast to read or operate when the blocks are already created. Filling blocks is not efficient because all the (possibly many) strings have to be compared with the new string each time. If that becomes a bottleneck, a more efficient structure like a map should be used. </p>

</div>
</div>
<a id="a955485c62a812660310a146bd6702b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955485c62a812660310a146bd6702b53">&#9670;&nbsp;</a></span>hash_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jzzBLOCKS::hash_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a>&#160;</td>
          <td class="paramname"><em>pblock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Hash a block in RAM</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pblock</td><td>A correctly allocated pJazzBlock with a valid header (size).</td></tr>
  </table>
  </dd>
</dl>
<p>Writes the output to the hash64 field of the header. </p>

</div>
</div>
<a id="a96957672c632368038a0b090c7bb4d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96957672c632368038a0b090c7bb4d8a">&#9670;&nbsp;</a></span>is_last_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::is_last_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpersistedKey.html">persistedKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare a key with KEY_SPACE_END. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The <a class="el" href="structpersistedKey.html">persistedKey</a> to be compared.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the key is identical to KEY_SPACE_END. </dd></dl>

</div>
</div>
<a id="a6aa302c2507dc597b45e63b3e5ad79fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa302c2507dc597b45e63b3e5ad79fe">&#9670;&nbsp;</a></span>kill_source()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::kill_source </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Kill a source, both from the lmdb persistence and from the source[] vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the source to be killed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not.</dd></dl>
<p>NOTE: <a class="el" href="classjzzBLOCKS.html#a6aa302c2507dc597b45e63b3e5ad79fe">kill_source()</a> is EXTREMELY not thread safe! Indices to ALL sources may change. Unsafe use of: numsources, source_nam, source_open, source_dbi. </p>

</div>
</div>
<a id="a783907d6a43158cec15ab36fb5d21b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783907d6a43158cec15ab36fb5d21b99">&#9670;&nbsp;</a></span>new_block_C_BOOL_rep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::new_block_C_BOOL_rep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#ab445aeb9ff3b0956d22aa990f41b240a">pBoolBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>pb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="structblock__C__BOOL.html">block_C_BOOL</a> by repeating a value a number of times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pb</td><td>The address of a pBoolBlock allocated for the object. The caller is responsible of freeing this with JAZZFREE(., RAM_ALLOC_C_BOOL). </td></tr>
    <tr><td class="paramname">x</td><td>The value to be initialized. </td></tr>
    <tr><td class="paramname">times</td><td>The number of times to repeat that value == length of the resulting vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not. </dd></dl>

</div>
</div>
<a id="a5bd61e4e34e2e6957dec092bcda63898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd61e4e34e2e6957dec092bcda63898">&#9670;&nbsp;</a></span>new_block_C_CHARS_rep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::new_block_C_CHARS_rep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#aadd3847e953c0a4cb4671bdff4805704">pCharBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>pb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="structblock__C__OFFS__CHARS.html">block_C_OFFS_CHARS</a> by repeating a value a number of times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pb</td><td>The address of a pCharBlock allocated for the object. The caller is responsible of freeing this with JAZZFREE(., RAM_ALLOC_C_OFFS_CHARS). </td></tr>
    <tr><td class="paramname">str</td><td>The string to be copied many times. NULL can be used to indicate NA (also a string of length 0). </td></tr>
    <tr><td class="paramname">times</td><td>The number of times to repeat that value == length of the resulting vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not.</dd></dl>
<p>This is not the usual way to create a <a class="el" href="structblock__C__OFFS__CHARS.html">block_C_OFFS_CHARS</a> since it only allocates the necessary RAM to store the block. It does exactly as announced, but managing strings is not trivial since the amount of RAM that will be necessary can only be guessed. See functions JAZZALLOC(., RAM_ALLOC_C_OFFS_CHARS, .) <a class="el" href="classjzzBLOCKS.html#a210476681839337c293c78e83c5eb5b5">format_C_OFFS_CHARS()</a>, <a class="el" href="classjzzBLOCKS.html#abe5acfd7a068624197b21bfc1751c553">get_string_idx_C_OFFS_CHARS()</a> and <a class="el" href="classjzzBLOCKS.html#ac53acaefd5beecc4e32fabe47ae48981">realloc_C_OFFS_CHARS()</a> for proper string management and use this only when it does exactly what you need (i.e, you have no intentions to further expand the block). </p>

</div>
</div>
<a id="a4ec6115998cc87a0572d729a54f7a91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec6115998cc87a0572d729a54f7a91e">&#9670;&nbsp;</a></span>new_block_C_INTEGER_rep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::new_block_C_INTEGER_rep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#a127962256c772083f0f393df2909f91f">pIntBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>pb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="structblock__C__INTEGER.html">block_C_INTEGER</a> by repeating a value a number of times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pb</td><td>The address of a pIntBlock allocated for the object. The caller is responsible of freeing this with JAZZFREE(., RAM_ALLOC_C_INTEGER). </td></tr>
    <tr><td class="paramname">x</td><td>The value to be initialized. </td></tr>
    <tr><td class="paramname">times</td><td>The number of times to repeat that value == length of the resulting vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not.</dd></dl>
<p>The type of the block can be changed later from BLOCKTYPE_C_INTEGER to BLOCKTYPE_C_FACTOR or BLOCKTYPE_C_GRADE using <a class="el" href="classjzzBLOCKS.html#a99a2f45f0fcfacfb3a4923b4add5a8d1">reinterpret_cast_block()</a>. </p>

</div>
</div>
<a id="a4753c9942dafef757c8edc4a244a3c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4753c9942dafef757c8edc4a244a3c27">&#9670;&nbsp;</a></span>new_block_C_INTEGER_seq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::new_block_C_INTEGER_seq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#a127962256c772083f0f393df2909f91f">pIntBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>pb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>by</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="structblock__C__INTEGER.html">block_C_INTEGER</a> using a simple sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pb</td><td>The address of a pIntBlock allocated for the object. The caller is responsible of freeing this with JAZZFREE(., RAM_ALLOC_C_INTEGER). </td></tr>
    <tr><td class="paramname">from</td><td>The starting value. </td></tr>
    <tr><td class="paramname">to</td><td>The end value (may not be included, is the supremum or infimum when the increment is negative). </td></tr>
    <tr><td class="paramname">by</td><td>The increment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not.</dd></dl>
<p>The increment may be negative, in that case "from" must be bigger than "to".</p>
<p>The type of the block can be changed later from BLOCKTYPE_C_INTEGER to BLOCKTYPE_C_FACTOR or BLOCKTYPE_C_GRADE using <a class="el" href="classjzzBLOCKS.html#a99a2f45f0fcfacfb3a4923b4add5a8d1">reinterpret_cast_block()</a>. </p>

</div>
</div>
<a id="aa3c608fdbb9b234b768c4fba0f85961d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c608fdbb9b234b768c4fba0f85961d">&#9670;&nbsp;</a></span>new_block_C_RAW_once()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::new_block_C_RAW_once </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#aa9994b1f3f32f62097cbf195a69143c1">pRawBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>pb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="structblock__C__RAW.html">block_C_RAW</a> by loading anything into it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pb</td><td>The address of a pRawBlock allocated for the object. The caller is responsible of freeing this with JAZZFREE(., RAM_ALLOC_C_RAW). </td></tr>
    <tr><td class="paramname">ps</td><td>The string to be copied many times. </td></tr>
    <tr><td class="paramname">size</td><td>The size in bytes of the object pointed by ps.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not.</dd></dl>
<p>The type of the block can be changed later from BLOCKTYPE_RAW_ANYTHING to any type &gt;= BLOCKTYPE_RAW_ANYTHING using <a class="el" href="classjzzBLOCKS.html#a99a2f45f0fcfacfb3a4923b4add5a8d1">reinterpret_cast_block()</a>. </p>

</div>
</div>
<a id="a3df50033255473f597ee93f27abc943d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df50033255473f597ee93f27abc943d">&#9670;&nbsp;</a></span>new_block_C_REAL_rep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::new_block_C_REAL_rep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#adc22cd7c8551bf5965d062da19f3bfc1">pRealBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>pb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>times</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="structblock__C__REAL.html">block_C_REAL</a> by repeating a value a number of times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pb</td><td>The address of a pRealBlock allocated for the object. The caller is responsible of freeing this with JAZZFREE(., RAM_ALLOC_C_REAL). </td></tr>
    <tr><td class="paramname">x</td><td>The value to be initialized. </td></tr>
    <tr><td class="paramname">times</td><td>The number of times to repeat that value == length of the resulting vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not.</dd></dl>
<p>The type of the block can be changed later from BLOCKTYPE_C_REAL to BLOCKTYPE_C_TIMESEC using <a class="el" href="classjzzBLOCKS.html#a99a2f45f0fcfacfb3a4923b4add5a8d1">reinterpret_cast_block()</a>. </p>

</div>
</div>
<a id="aad0143be352e704c2dbcaaa87d25b539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0143be352e704c2dbcaaa87d25b539">&#9670;&nbsp;</a></span>new_block_C_REAL_seq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::new_block_C_REAL_seq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#adc22cd7c8551bf5965d062da19f3bfc1">pRealBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>pb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>by</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="structblock__C__REAL.html">block_C_REAL</a> using a simple sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pb</td><td>The address of a pRealBlock allocated for the object. The caller is responsible of freeing this with JAZZFREE(., RAM_ALLOC_C_REAL). </td></tr>
    <tr><td class="paramname">from</td><td>The starting value. </td></tr>
    <tr><td class="paramname">to</td><td>The end value (may not be included, is the supremum or infimum when the increment is negative). </td></tr>
    <tr><td class="paramname">by</td><td>The increment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not.</dd></dl>
<p>The increment may be negative, in that case "from" must be bigger than "to".</p>
<p>The type of the block can be changed later from BLOCKTYPE_C_REAL to BLOCKTYPE_C_TIMESEC using <a class="el" href="classjzzBLOCKS.html#a99a2f45f0fcfacfb3a4923b4add5a8d1">reinterpret_cast_block()</a>. </p>

</div>
</div>
<a id="a8f9bd486366fedb09219847e965fdccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f9bd486366fedb09219847e965fdccb">&#9670;&nbsp;</a></span>new_block_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::new_block_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a>&#160;</td>
          <td class="paramname"><em>psrc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>pdest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a block to a new <a class="el" href="jazzCommons_8h.html#af5b2b15a0f1e5c3d10303c34593b2bfa" title="This macro expands to JAZZALLOCVEC() or JAZZALLOCSTR() and is the ONLY allocation method used!!! ...">JAZZALLOC()</a>ed block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psrc</td><td>The pJazzBlock to be copied. </td></tr>
    <tr><td class="paramname">pdest</td><td>The address of a pJazzBlock where a block of the same size will be allocated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not.</dd></dl>
<p>This function does nothing with the source block, except copying it. The typical use is to create a block from an lmdb block returned by <a class="el" href="classjzzBLOCKS.html#a9ab954eb93e352f79ea22d147730d958">block_get()</a> but this will not <a class="el" href="classjzzBLOCKS.html#abab95b3472ae05b51381841a278ceb4a">block_unprotect()</a> the source pointer. It works on any source regardless of being <a class="el" href="jazzCommons_8h.html#af5b2b15a0f1e5c3d10303c34593b2bfa" title="This macro expands to JAZZALLOCVEC() or JAZZALLOCSTR() and is the ONLY allocation method used!!! ...">JAZZALLOC()</a>ed or <a class="el" href="classjzzBLOCKS.html#a9ab954eb93e352f79ea22d147730d958">block_get()</a>ed.</p>
<p>The destination is <a class="el" href="jazzCommons_8h.html#af5b2b15a0f1e5c3d10303c34593b2bfa" title="This macro expands to JAZZALLOCVEC() or JAZZALLOCSTR() and is the ONLY allocation method used!!! ...">JAZZALLOC()</a>ed and owned by the caller who must JAZZFREE it later. </p>

</div>
</div>
<a id="af91e7163989a8a9a6e9453c85cbe1a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91e7163989a8a9a6e9453c85cbe1a79">&#9670;&nbsp;</a></span>new_source()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::new_source </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new lmbd dbi and add it as a new source to the source[] vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the source to be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not.</dd></dl>
<p>NOTE: <a class="el" href="classjzzBLOCKS.html#af91e7163989a8a9a6e9453c85cbe1a79">new_source()</a> is not thread safe! Unsafe use of: numsources, source_nam, source_open, source_dbi. </p>

</div>
</div>
<a id="a3dc841e46577b9cf110f8bd1987efa76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc841e46577b9cf110f8bd1987efa76">&#9670;&nbsp;</a></span>next_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::next_key </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpersistedKey.html">persistedKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scan all the keys stored in a source. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The index of an open source. (As returned by <a class="el" href="classjzzBLOCKS.html#a1e3fa0af4745c757a3b0f59daf2af9f9">get_source_idx()</a>.) </td></tr>
    <tr><td class="paramname">key</td><td>Input: The last key returned by a previous call to <a class="el" href="classjzzBLOCKS.html#a3dc841e46577b9cf110f8bd1987efa76">next_key()</a> or KEY_SPACE_START to search the first one. Output: The next key after the input key or KEY_SPACE_END if the previous key was the last.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if errors such as invalid source happen.</dd></dl>
<p>There are two functions <a class="el" href="classjzzBLOCKS.html#a3692c1344a69622159645b90821b2bfe">set_first_key()</a> and <a class="el" href="classjzzBLOCKS.html#a96957672c632368038a0b090c7bb4d8a">is_last_key()</a> to give an simple approach to search: </p><pre class="fragment">set_first_key(key);
while (!is_last_key(key) next_key(idx, key);
</pre><p>Reaching the end once is not an error and does not return false, but attempting to search after KEY_SPACE_END does. </p>

</div>
</div>
<a id="a9d37e658424ae9e2f88aec48f9ab9346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d37e658424ae9e2f88aec48f9ab9346">&#9670;&nbsp;</a></span>num_sources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int jzzBLOCKS::num_sources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the private variable numsources. </p>

</div>
</div>
<a id="a428ad286f1d7ceafe3826f7b535a0600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428ad286f1d7ceafe3826f7b535a0600">&#9670;&nbsp;</a></span>open_all_sources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::open_all_sources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locate all the sources in the current lmdb environment, add them to the source[] vector and open them all for reading.</p>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not. </dd></dl>

</div>
</div>
<a id="ac53acaefd5beecc4e32fabe47ae48981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53acaefd5beecc4e32fabe47ae48981">&#9670;&nbsp;</a></span>realloc_C_OFFS_CHARS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::realloc_C_OFFS_CHARS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#aadd3847e953c0a4cb4671bdff4805704">pCharBlock</a> &amp;&#160;</td>
          <td class="paramname"><em>pstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extra_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reallocate a <a class="el" href="structblock__C__OFFS__CHARS.html">block_C_OFFS_CHARS</a> to a bigger object when more string space is required. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pstr</td><td>The address of an existing pCharBlock of type <a class="el" href="structblock__C__OFFS__CHARS.html">block_C_OFFS_CHARS</a>. It will be copied to a bigger one and freed. </td></tr>
    <tr><td class="paramname">extra_length</td><td>The difference between the old allocation size and the new one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not.</dd></dl>
<p>See <a class="el" href="classjzzBLOCKS.html#a210476681839337c293c78e83c5eb5b5">format_C_OFFS_CHARS()</a> for an explanation on how <a class="el" href="structblock__C__OFFS__CHARS.html">block_C_OFFS_CHARS</a> are filled.</p>
<p>The old object is freed and replaced by a new one where its content is copied first. </p>

</div>
</div>
<a id="a99a2f45f0fcfacfb3a4923b4add5a8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a2f45f0fcfacfb3a4923b4add5a8d1">&#9670;&nbsp;</a></span>reinterpret_cast_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::reinterpret_cast_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="jazzCommons_8h.html#a81770bae7c18abbb26281974e3d1c296">pJazzBlock</a>&#160;</td>
          <td class="paramname"><em>pb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the type of an integer, real or raw block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pb</td><td>A pJazzBlock to be changed </td></tr>
    <tr><td class="paramname">type</td><td>The new type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the change is possible and was done.</dd></dl>
<p>The allowed changes are: </p><pre class="fragment">BLOCKTYPE_C_INTEGER with BLOCKTYPE_C_FACTOR or BLOCKTYPE_C_GRADE in any combination,
BLOCKTYPE_C_REAL to BLOCKTYPE_C_TIMESEC and vice-versa,
Any type &gt;= BLOCKTYPE_RAW_ANYTHING to any other type &gt;= BLOCKTYPE_RAW_ANYTHING

No allocation, conversion or change of block headers other than the type is done. Use this function to check errors, rather that doing the
</pre><p> change directly. </p>

</div>
</div>
<a id="aec728ae2375cde2a460a0ca5d845dd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec728ae2375cde2a460a0ca5d845dd9d">&#9670;&nbsp;</a></span>reload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::reload </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reload of <a class="el" href="classjzzBLOCKS.html">jzzBLOCKS</a></p>
<dl class="section return"><dt>Returns</dt><dd>true and log(LOG_INFO, "further details"). No reloading implemented.</dd></dl>
<p>see <a class="el" href="classjazzService.html#a7beba95e5bf02b80c6285c3854b86863">jazzService::reload()</a> </p>

<p>Reimplemented from <a class="el" href="classjazzService.html#a7beba95e5bf02b80c6285c3854b86863">jazzService</a>.</p>

<p>Reimplemented in <a class="el" href="classjzzBLOCKCONV.html#a0763393f3daef8f360a6ada819a0ff06">jzzBLOCKCONV</a>.</p>

</div>
</div>
<a id="a3692c1344a69622159645b90821b2bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3692c1344a69622159645b90821b2bfe">&#9670;&nbsp;</a></span>set_first_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jzzBLOCKS::set_first_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpersistedKey.html">persistedKey</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a key with the value in KEY_SPACE_START to start a <a class="el" href="classjzzBLOCKS.html#a3dc841e46577b9cf110f8bd1987efa76">next_key()</a> search from the beginning of a source. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The first key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af91ce223623548083b122b444eb9019d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af91ce223623548083b122b444eb9019d">&#9670;&nbsp;</a></span>source_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::source_name </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="jzzBLOCKS_8h.html#a9c29cd2ce79349cc6968a2aca0a76eb1">sourceName</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the name of a source stored in source[] by index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index. </td></tr>
    <tr><td class="paramname">name</td><td>A pointer to return the name to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not. </dd></dl>

</div>
</div>
<a id="a7ff3602a2a29e159dd696922929a1c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ff3602a2a29e159dd696922929a1c7f">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start of <a class="el" href="classjzzBLOCKS.html">jzzBLOCKS</a></p>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false and log(LOG_MISS, "further details") if not.</dd></dl>
<p>This service initialization checks configuration values related with persistence and starts lmdb with configured values. </p>

<p>Reimplemented from <a class="el" href="classjazzService.html#a47354269a6ebcf7f72bf3901a7c91b5f">jazzService</a>.</p>

<p>Reimplemented in <a class="el" href="classjzzBLOCKCONV.html#a7ef37d4ac521fba24da05b595e6e6b21">jzzBLOCKCONV</a>.</p>

</div>
</div>
<a id="ae41357cdf599a7a763422ac0c0e2b973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41357cdf599a7a763422ac0c0e2b973">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool jzzBLOCKS::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stop of <a class="el" href="classjzzBLOCKS.html">jzzBLOCKS</a></p>
<dl class="section return"><dt>Returns</dt><dd>true and log(LOG_INFO, "further details"). No error checking.</dd></dl>
<p>see <a class="el" href="classjazzService.html#af76b6aacbc5635efbae36088b71909d6">jazzService::stop()</a> </p>

<p>Reimplemented from <a class="el" href="classjazzService.html#af76b6aacbc5635efbae36088b71909d6">jazzService</a>.</p>

<p>Reimplemented in <a class="el" href="classjzzBLOCKCONV.html#a8a6b4e8e67453a760ef43b442b2751c4">jzzBLOCKCONV</a>.</p>

</div>
</div>
<a id="a4f8c0ed33ac6ad21feac4d120a232325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8c0ed33ac6ad21feac4d120a232325">&#9670;&nbsp;</a></span>strcmp_keys()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int jzzBLOCKS::strcmp_keys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpersistedKey.html">persistedKey</a>&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpersistedKey.html">persistedKey</a>&#160;</td>
          <td class="paramname"><em>key2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compare two (<a class="el" href="structpersistedKey.html">persistedKey</a>) keys as char * with strcmp(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key1</td><td>The first key. </td></tr>
    <tr><td class="paramname">key2</td><td>The second key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same as strcmp() </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="jzzBLOCKS_8h_source.html">jzzBLOCKS.h</a></li>
<li><a class="el" href="jzzBLOCKS_8cpp.html">jzzBLOCKS.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
